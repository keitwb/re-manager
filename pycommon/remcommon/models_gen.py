# THIS FILE IS GENERATED FROM models/generate.sh
# DO NOT EDIT THIS FILE!

from bson.objectid import ObjectId
# This code parses date/times, so please
#
#     pip install python-dateutil
#
# To use this code, make sure you
#
#     import json
#
# and then, to convert JSON from a string, do
#
#     result = collection_name_from_dict(json.loads(json_string))
#     result = common_from_dict(json.loads(json_string))
#     result = insurance_policy_from_dict(json.loads(json_string))
#     result = lease_from_dict(json.loads(json_string))
#     result = media_from_dict(json.loads(json_string))
#     result = mongo_doc_from_dict(json.loads(json_string))
#     result = note_from_dict(json.loads(json_string))
#     result = parcel_info_from_dict(json.loads(json_string))
#     result = party_from_dict(json.loads(json_string))
#     result = property_from_dict(json.loads(json_string))
#     result = user_from_dict(json.loads(json_string))

from enum import Enum
from dataclasses import dataclass
from typing import Any, Optional, List, Dict, TypeVar, Callable, Type, cast
from datetime import datetime
import dateutil.parser


T = TypeVar("T")
EnumT = TypeVar("EnumT", bound=Enum)


def from_str(x: Any) -> str:
    assert isinstance(x, str)
    return x


def from_none(x: Any) -> Any:
    assert x is None
    return x


def from_union(fs, x):
    for f in fs:
        try:
            return f(x)
        except:
            pass
    assert False


def from_datetime(x: Any) -> datetime:
    return dateutil.parser.parse(x)


def from_list(f: Callable[[Any], T], x: Any) -> List[T]:
    assert isinstance(x, list)
    return [f(y) for y in x]


def to_class(c: Type[T], x: Any) -> dict:
    assert isinstance(x, c)
    return cast(Any, x).to_dict()


def from_float(x: Any) -> float:
    assert isinstance(x, (float, int)) and not isinstance(x, bool)
    return float(x)


def to_enum(c: Type[EnumT], x: Any) -> EnumT:
    assert isinstance(x, c)
    return x.value


def to_float(x: Any) -> float:
    assert isinstance(x, float)
    return x


def from_int(x: Any) -> int:
    assert isinstance(x, int) and not isinstance(x, bool)
    return x


def from_bool(x: Any) -> bool:
    assert isinstance(x, bool)
    return x


def from_dict(f: Callable[[Any], T], x: Any) -> Dict[str, T]:
    assert isinstance(x, dict)
    return { k: f(v) for (k, v) in x.items() }


class CollectionName(Enum):
    """A set of Mongo collection names for the various models"""
    INSURANCE_POLICIES = "insurancePolicies"
    LEASES = "leases"
    MEDIA_FILES = "media.files"
    NOTES = "notes"
    PARTIES = "parties"
    PROPERTIES = "properties"
    USERS = "users"


@dataclass
class OID:
    """A JSON-encoded BSON ObjectId
    
    The id of the user that created this object
    
    The id of the user that last modified this object
    """
    oid: str

    @staticmethod
    def from_dict(obj: Any) -> 'ObjectId':
        assert isinstance(obj, dict)
        oid = from_str(obj.get("$oid"))
        return ObjectId(oid)

    def to_dict(self) -> dict:
        result: dict = {}
        result["$oid"] = from_str(self.oid)
        return result


@dataclass
class InsurancePolicy:
    """An insurance policy that applies to one or more properties"""
    id: ObjectId
    """A placeholder where errors concerning the object can go"""
    error: Optional[str] = None
    """The id of the user that created this object"""
    created_by: Optional[ObjectId] = None
    """The date the object was first created"""
    created_date: Optional[datetime] = None
    """The id of the user that last modified this object"""
    last_modified_by: Optional[ObjectId] = None
    """The date of the last update to the object"""
    modified_date: Optional[datetime] = None
    description: Optional[str] = None
    end_date: Optional[datetime] = None
    media_ids: Optional[List[ObjectId]] = None
    start_date: Optional[datetime] = None

    @staticmethod
    def from_dict(obj: Any) -> 'InsurancePolicy':
        assert isinstance(obj, dict)
        id = (lambda x: x)(obj.get("_id"))
        error = from_union([from_str, from_none], obj.get("_error"))
        created_by = from_union([(lambda x: x), from_none], obj.get("createdBy"))
        created_date = from_union([(lambda x: x), from_none], obj.get("createdDate"))
        last_modified_by = from_union([(lambda x: x), from_none], obj.get("lastModifiedBy"))
        modified_date = from_union([(lambda x: x), from_none], obj.get("modifiedDate"))
        description = from_union([from_str, from_none], obj.get("description"))
        end_date = from_union([(lambda x: x), from_none], obj.get("endDate"))
        media_ids = from_union([lambda x: from_list((lambda x: x), x), from_none], obj.get("mediaIds"))
        start_date = from_union([(lambda x: x), from_none], obj.get("startDate"))
        return InsurancePolicy(id, error, created_by, created_date, last_modified_by, modified_date, description, end_date, media_ids, start_date)

    def to_dict(self) -> dict:
        result: dict = {}
        result["_id"] = to_class(ObjectId, self.id)
        result["_error"] = from_union([from_str, from_none], self.error)
        result["createdBy"] = from_union([lambda x: to_class(ObjectId, x), from_none], self.created_by)
        result["createdDate"] = from_union([lambda x: x.isoformat(), from_none], self.created_date)
        result["lastModifiedBy"] = from_union([lambda x: to_class(ObjectId, x), from_none], self.last_modified_by)
        result["modifiedDate"] = from_union([lambda x: x.isoformat(), from_none], self.modified_date)
        result["description"] = from_union([from_str, from_none], self.description)
        result["endDate"] = from_union([lambda x: x.isoformat(), from_none], self.end_date)
        result["mediaIds"] = from_union([lambda x: from_list(lambda x: to_class(ObjectId, x), x), from_none], self.media_ids)
        result["startDate"] = from_union([lambda x: x.isoformat(), from_none], self.start_date)
        return result


class LeaseType(Enum):
    GROSS = "gross"
    N = "N"
    NN = "NN"
    NNN = "NNN"
    OPTION = "option"


@dataclass
class Note:
    """A note that gives an update on an item"""
    id: ObjectId
    """A placeholder where errors concerning the object can go"""
    error: Optional[str] = None
    """The id of the user that created this object"""
    created_by: Optional[ObjectId] = None
    """The date the object was first created"""
    created_date: Optional[datetime] = None
    """The id of the user that last modified this object"""
    last_modified_by: Optional[ObjectId] = None
    """The date of the last update to the object"""
    modified_date: Optional[datetime] = None
    media: Optional[List[ObjectId]] = None
    note: Optional[str] = None
    title: Optional[str] = None

    @staticmethod
    def from_dict(obj: Any) -> 'Note':
        assert isinstance(obj, dict)
        id = (lambda x: x)(obj.get("_id"))
        error = from_union([from_str, from_none], obj.get("_error"))
        created_by = from_union([(lambda x: x), from_none], obj.get("createdBy"))
        created_date = from_union([(lambda x: x), from_none], obj.get("createdDate"))
        last_modified_by = from_union([(lambda x: x), from_none], obj.get("lastModifiedBy"))
        modified_date = from_union([(lambda x: x), from_none], obj.get("modifiedDate"))
        media = from_union([lambda x: from_list((lambda x: x), x), from_none], obj.get("media"))
        note = from_union([from_str, from_none], obj.get("note"))
        title = from_union([from_str, from_none], obj.get("title"))
        return Note(id, error, created_by, created_date, last_modified_by, modified_date, media, note, title)

    def to_dict(self) -> dict:
        result: dict = {}
        result["_id"] = to_class(ObjectId, self.id)
        result["_error"] = from_union([from_str, from_none], self.error)
        result["createdBy"] = from_union([lambda x: to_class(ObjectId, x), from_none], self.created_by)
        result["createdDate"] = from_union([lambda x: x.isoformat(), from_none], self.created_date)
        result["lastModifiedBy"] = from_union([lambda x: to_class(ObjectId, x), from_none], self.last_modified_by)
        result["modifiedDate"] = from_union([lambda x: x.isoformat(), from_none], self.modified_date)
        result["media"] = from_union([lambda x: from_list(lambda x: to_class(ObjectId, x), x), from_none], self.media)
        result["note"] = from_union([from_str, from_none], self.note)
        result["title"] = from_union([from_str, from_none], self.title)
        return result


class TermUnit(Enum):
    MONTHS = "months"
    QUARTERS = "quarters"
    YEARS = "years"


@dataclass
class Lease:
    """A lease for one or more properties"""
    id: ObjectId
    """A placeholder where errors concerning the object can go"""
    error: Optional[str] = None
    """The id of the user that created this object"""
    created_by: Optional[ObjectId] = None
    """The date the object was first created"""
    created_date: Optional[datetime] = None
    """The id of the user that last modified this object"""
    last_modified_by: Optional[ObjectId] = None
    """The date of the last update to the object"""
    modified_date: Optional[datetime] = None
    description: Optional[str] = None
    lease_type: Optional[LeaseType] = None
    lessees: Optional[List[ObjectId]] = None
    notes: Optional[List[Note]] = None
    rate: Optional[float] = None
    start_date: Optional[datetime] = None
    term_length: Optional[float] = None
    term_unit: Optional[TermUnit] = None

    @staticmethod
    def from_dict(obj: Any) -> 'Lease':
        assert isinstance(obj, dict)
        id = (lambda x: x)(obj.get("_id"))
        error = from_union([from_str, from_none], obj.get("_error"))
        created_by = from_union([(lambda x: x), from_none], obj.get("createdBy"))
        created_date = from_union([(lambda x: x), from_none], obj.get("createdDate"))
        last_modified_by = from_union([(lambda x: x), from_none], obj.get("lastModifiedBy"))
        modified_date = from_union([(lambda x: x), from_none], obj.get("modifiedDate"))
        description = from_union([from_str, from_none], obj.get("description"))
        lease_type = from_union([LeaseType, from_none], obj.get("leaseType"))
        lessees = from_union([lambda x: from_list((lambda x: x), x), from_none], obj.get("lessees"))
        notes = from_union([lambda x: from_list(Note.from_dict, x), from_none], obj.get("notes"))
        rate = from_union([from_float, from_none], obj.get("rate"))
        start_date = from_union([(lambda x: x), from_none], obj.get("startDate"))
        term_length = from_union([from_float, from_none], obj.get("termLength"))
        term_unit = from_union([TermUnit, from_none], obj.get("termUnit"))
        return Lease(id, error, created_by, created_date, last_modified_by, modified_date, description, lease_type, lessees, notes, rate, start_date, term_length, term_unit)

    def to_dict(self) -> dict:
        result: dict = {}
        result["_id"] = to_class(ObjectId, self.id)
        result["_error"] = from_union([from_str, from_none], self.error)
        result["createdBy"] = from_union([lambda x: to_class(ObjectId, x), from_none], self.created_by)
        result["createdDate"] = from_union([lambda x: x.isoformat(), from_none], self.created_date)
        result["lastModifiedBy"] = from_union([lambda x: to_class(ObjectId, x), from_none], self.last_modified_by)
        result["modifiedDate"] = from_union([lambda x: x.isoformat(), from_none], self.modified_date)
        result["description"] = from_union([from_str, from_none], self.description)
        result["leaseType"] = from_union([lambda x: to_enum(LeaseType, x), from_none], self.lease_type)
        result["lessees"] = from_union([lambda x: from_list(lambda x: to_class(ObjectId, x), x), from_none], self.lessees)
        result["notes"] = from_union([lambda x: from_list(lambda x: to_class(Note, x), x), from_none], self.notes)
        result["rate"] = from_union([to_float, from_none], self.rate)
        result["startDate"] = from_union([lambda x: x.isoformat(), from_none], self.start_date)
        result["termLength"] = from_union([to_float, from_none], self.term_length)
        result["termUnit"] = from_union([lambda x: to_enum(TermUnit, x), from_none], self.term_unit)
        return result


@dataclass
class Metadata:
    description: Optional[str] = None
    tags: Optional[List[str]] = None

    @staticmethod
    def from_dict(obj: Any) -> 'Metadata':
        assert isinstance(obj, dict)
        description = from_union([from_str, from_none], obj.get("description"))
        tags = from_union([lambda x: from_list(from_str, x), from_none], obj.get("tags"))
        return Metadata(description, tags)

    def to_dict(self) -> dict:
        result: dict = {}
        result["description"] = from_union([from_str, from_none], self.description)
        result["tags"] = from_union([lambda x: from_list(from_str, x), from_none], self.tags)
        return result


@dataclass
class Media:
    """A media file that is associated with a property, lease, note, etc."""
    id: ObjectId
    """A placeholder where errors concerning the object can go"""
    error: Optional[str] = None
    """The id of the user that created this object"""
    created_by: Optional[ObjectId] = None
    """The date the object was first created"""
    created_date: Optional[datetime] = None
    """The id of the user that last modified this object"""
    last_modified_by: Optional[ObjectId] = None
    """The date of the last update to the object"""
    modified_date: Optional[datetime] = None
    chunk_size: Optional[float] = None
    content_type: Optional[str] = None
    filename: Optional[str] = None
    length: Optional[float] = None
    md5: Optional[str] = None
    upload_date: Optional[datetime] = None
    metadata: Optional[Metadata] = None

    @staticmethod
    def from_dict(obj: Any) -> 'Media':
        assert isinstance(obj, dict)
        id = (lambda x: x)(obj.get("_id"))
        error = from_union([from_str, from_none], obj.get("_error"))
        created_by = from_union([(lambda x: x), from_none], obj.get("createdBy"))
        created_date = from_union([(lambda x: x), from_none], obj.get("createdDate"))
        last_modified_by = from_union([(lambda x: x), from_none], obj.get("lastModifiedBy"))
        modified_date = from_union([(lambda x: x), from_none], obj.get("modifiedDate"))
        chunk_size = from_union([from_float, from_none], obj.get("chunkSize"))
        content_type = from_union([from_str, from_none], obj.get("contentType"))
        filename = from_union([from_str, from_none], obj.get("filename"))
        length = from_union([from_float, from_none], obj.get("length"))
        md5 = from_union([from_str, from_none], obj.get("md5"))
        upload_date = from_union([(lambda x: x), from_none], obj.get("uploadDate"))
        metadata = from_union([Metadata.from_dict, from_none], obj.get("metadata"))
        return Media(id, error, created_by, created_date, last_modified_by, modified_date, chunk_size, content_type, filename, length, md5, upload_date, metadata)

    def to_dict(self) -> dict:
        result: dict = {}
        result["_id"] = to_class(ObjectId, self.id)
        result["_error"] = from_union([from_str, from_none], self.error)
        result["createdBy"] = from_union([lambda x: to_class(ObjectId, x), from_none], self.created_by)
        result["createdDate"] = from_union([lambda x: x.isoformat(), from_none], self.created_date)
        result["lastModifiedBy"] = from_union([lambda x: to_class(ObjectId, x), from_none], self.last_modified_by)
        result["modifiedDate"] = from_union([lambda x: x.isoformat(), from_none], self.modified_date)
        result["chunkSize"] = from_union([to_float, from_none], self.chunk_size)
        result["contentType"] = from_union([from_str, from_none], self.content_type)
        result["filename"] = from_union([from_str, from_none], self.filename)
        result["length"] = from_union([to_float, from_none], self.length)
        result["md5"] = from_union([from_str, from_none], self.md5)
        result["uploadDate"] = from_union([lambda x: x.isoformat(), from_none], self.upload_date)
        result["metadata"] = from_union([lambda x: to_class(Metadata, x), from_none], self.metadata)
        return result


@dataclass
class MongoDoc:
    id: ObjectId
    """A placeholder where errors concerning the object can go"""
    error: Optional[str] = None
    """The id of the user that created this object"""
    created_by: Optional[ObjectId] = None
    """The date the object was first created"""
    created_date: Optional[datetime] = None
    """The id of the user that last modified this object"""
    last_modified_by: Optional[ObjectId] = None
    """The date of the last update to the object"""
    modified_date: Optional[datetime] = None

    @staticmethod
    def from_dict(obj: Any) -> 'MongoDoc':
        assert isinstance(obj, dict)
        id = (lambda x: x)(obj.get("_id"))
        error = from_union([from_str, from_none], obj.get("_error"))
        created_by = from_union([(lambda x: x), from_none], obj.get("createdBy"))
        created_date = from_union([(lambda x: x), from_none], obj.get("createdDate"))
        last_modified_by = from_union([(lambda x: x), from_none], obj.get("lastModifiedBy"))
        modified_date = from_union([(lambda x: x), from_none], obj.get("modifiedDate"))
        return MongoDoc(id, error, created_by, created_date, last_modified_by, modified_date)

    def to_dict(self) -> dict:
        result: dict = {}
        result["_id"] = to_class(ObjectId, self.id)
        result["_error"] = from_union([from_str, from_none], self.error)
        result["createdBy"] = from_union([lambda x: to_class(ObjectId, x), from_none], self.created_by)
        result["createdDate"] = from_union([lambda x: x.isoformat(), from_none], self.created_date)
        result["lastModifiedBy"] = from_union([lambda x: to_class(ObjectId, x), from_none], self.last_modified_by)
        result["modifiedDate"] = from_union([lambda x: x.isoformat(), from_none], self.modified_date)
        return result


@dataclass
class ParcelInfo:
    """Information about a specific parcel"""
    acreage: Optional[float] = None
    boundary_wkt: Optional[str] = None
    owner_name: Optional[str] = None
    pin_number: Optional[str] = None
    street_address: Optional[str] = None

    @staticmethod
    def from_dict(obj: Any) -> 'ParcelInfo':
        assert isinstance(obj, dict)
        acreage = from_union([from_float, from_none], obj.get("acreage"))
        boundary_wkt = from_union([from_str, from_none], obj.get("boundaryWKT"))
        owner_name = from_union([from_str, from_none], obj.get("ownerName"))
        pin_number = from_union([from_str, from_none], obj.get("pinNumber"))
        street_address = from_union([from_str, from_none], obj.get("streetAddress"))
        return ParcelInfo(acreage, boundary_wkt, owner_name, pin_number, street_address)

    def to_dict(self) -> dict:
        result: dict = {}
        result["acreage"] = from_union([to_float, from_none], self.acreage)
        result["boundaryWKT"] = from_union([from_str, from_none], self.boundary_wkt)
        result["ownerName"] = from_union([from_str, from_none], self.owner_name)
        result["pinNumber"] = from_union([from_str, from_none], self.pin_number)
        result["streetAddress"] = from_union([from_str, from_none], self.street_address)
        return result


class TypeEnum(Enum):
    COMPANY = "company"
    PERSON = "person"


@dataclass
class Party:
    """A person or organization/company that interacts with real estate in some way, e.g. owner,
    lessee, contractors, etc.
    """
    id: ObjectId
    """A placeholder where errors concerning the object can go"""
    error: Optional[str] = None
    """The id of the user that created this object"""
    created_by: Optional[ObjectId] = None
    """The date the object was first created"""
    created_date: Optional[datetime] = None
    """The id of the user that last modified this object"""
    last_modified_by: Optional[ObjectId] = None
    """The date of the last update to the object"""
    modified_date: Optional[datetime] = None
    address: Optional[str] = None
    city: Optional[str] = None
    name: Optional[str] = None
    notes: Optional[Note] = None
    phone: Optional[str] = None
    state: Optional[str] = None
    sub_parties: Optional[List['Party']] = None
    type: Optional[TypeEnum] = None
    zipcode: Optional[str] = None

    @staticmethod
    def from_dict(obj: Any) -> 'Party':
        assert isinstance(obj, dict)
        id = (lambda x: x)(obj.get("_id"))
        error = from_union([from_str, from_none], obj.get("_error"))
        created_by = from_union([(lambda x: x), from_none], obj.get("createdBy"))
        created_date = from_union([(lambda x: x), from_none], obj.get("createdDate"))
        last_modified_by = from_union([(lambda x: x), from_none], obj.get("lastModifiedBy"))
        modified_date = from_union([(lambda x: x), from_none], obj.get("modifiedDate"))
        address = from_union([from_str, from_none], obj.get("address"))
        city = from_union([from_str, from_none], obj.get("city"))
        name = from_union([from_str, from_none], obj.get("name"))
        notes = from_union([Note.from_dict, from_none], obj.get("notes"))
        phone = from_union([from_str, from_none], obj.get("phone"))
        state = from_union([from_str, from_none], obj.get("state"))
        sub_parties = from_union([lambda x: from_list(Party.from_dict, x), from_none], obj.get("subParties"))
        type = from_union([TypeEnum, from_none], obj.get("type"))
        zipcode = from_union([from_str, from_none], obj.get("zipcode"))
        return Party(id, error, created_by, created_date, last_modified_by, modified_date, address, city, name, notes, phone, state, sub_parties, type, zipcode)

    def to_dict(self) -> dict:
        result: dict = {}
        result["_id"] = to_class(ObjectId, self.id)
        result["_error"] = from_union([from_str, from_none], self.error)
        result["createdBy"] = from_union([lambda x: to_class(ObjectId, x), from_none], self.created_by)
        result["createdDate"] = from_union([lambda x: x.isoformat(), from_none], self.created_date)
        result["lastModifiedBy"] = from_union([lambda x: to_class(ObjectId, x), from_none], self.last_modified_by)
        result["modifiedDate"] = from_union([lambda x: x.isoformat(), from_none], self.modified_date)
        result["address"] = from_union([from_str, from_none], self.address)
        result["city"] = from_union([from_str, from_none], self.city)
        result["name"] = from_union([from_str, from_none], self.name)
        result["notes"] = from_union([lambda x: to_class(Note, x), from_none], self.notes)
        result["phone"] = from_union([from_str, from_none], self.phone)
        result["state"] = from_union([from_str, from_none], self.state)
        result["subParties"] = from_union([lambda x: from_list(lambda x: to_class(Party, x), x), from_none], self.sub_parties)
        result["type"] = from_union([lambda x: to_enum(TypeEnum, x), from_none], self.type)
        result["zipcode"] = from_union([from_str, from_none], self.zipcode)
        return result


@dataclass
class Owner:
    id: Optional[ObjectId] = None
    portion: Optional[float] = None

    @staticmethod
    def from_dict(obj: Any) -> 'Owner':
        assert isinstance(obj, dict)
        id = from_union([(lambda x: x), from_none], obj.get("id"))
        portion = from_union([from_float, from_none], obj.get("portion"))
        return Owner(id, portion)

    def to_dict(self) -> dict:
        result: dict = {}
        result["id"] = from_union([lambda x: to_class(ObjectId, x), from_none], self.id)
        result["portion"] = from_union([to_float, from_none], self.portion)
        return result


class PropType(Enum):
    COMMERCIAL = "commercial"
    INDUSTRIAL = "industrial"
    LAND = "land"
    RESIDENTIAL = "residential"


@dataclass
class LineItem:
    amount_cents: Optional[int] = None
    description: Optional[str] = None

    @staticmethod
    def from_dict(obj: Any) -> 'LineItem':
        assert isinstance(obj, dict)
        amount_cents = from_union([from_int, from_none], obj.get("amountCents"))
        description = from_union([from_str, from_none], obj.get("description"))
        return LineItem(amount_cents, description)

    def to_dict(self) -> dict:
        result: dict = {}
        result["amountCents"] = from_union([from_int, from_none], self.amount_cents)
        result["description"] = from_union([from_str, from_none], self.description)
        return result


@dataclass
class Payment:
    amount_cents: Optional[int] = None
    payment_date: Optional[datetime] = None

    @staticmethod
    def from_dict(obj: Any) -> 'Payment':
        assert isinstance(obj, dict)
        amount_cents = from_union([from_int, from_none], obj.get("amountCents"))
        payment_date = from_union([(lambda x: x), from_none], obj.get("paymentDate"))
        return Payment(amount_cents, payment_date)

    def to_dict(self) -> dict:
        result: dict = {}
        result["amountCents"] = from_union([from_int, from_none], self.amount_cents)
        result["paymentDate"] = from_union([lambda x: x.isoformat(), from_none], self.payment_date)
        return result


@dataclass
class TaxBill:
    building_assessed_cents: Optional[int] = None
    due_date: Optional[datetime] = None
    land_assessed_cents: Optional[int] = None
    line_items: Optional[List[LineItem]] = None
    misc_assessed_cents: Optional[int] = None
    payments: Optional[List[Payment]] = None
    total_assessed_cents: Optional[int] = None

    @staticmethod
    def from_dict(obj: Any) -> 'TaxBill':
        assert isinstance(obj, dict)
        building_assessed_cents = from_union([from_int, from_none], obj.get("buildingAssessedCents"))
        due_date = from_union([(lambda x: x), from_none], obj.get("dueDate"))
        land_assessed_cents = from_union([from_int, from_none], obj.get("landAssessedCents"))
        line_items = from_union([lambda x: from_list(LineItem.from_dict, x), from_none], obj.get("lineItems"))
        misc_assessed_cents = from_union([from_int, from_none], obj.get("miscAssessedCents"))
        payments = from_union([lambda x: from_list(Payment.from_dict, x), from_none], obj.get("payments"))
        total_assessed_cents = from_union([from_int, from_none], obj.get("totalAssessedCents"))
        return TaxBill(building_assessed_cents, due_date, land_assessed_cents, line_items, misc_assessed_cents, payments, total_assessed_cents)

    def to_dict(self) -> dict:
        result: dict = {}
        result["buildingAssessedCents"] = from_union([from_int, from_none], self.building_assessed_cents)
        result["dueDate"] = from_union([lambda x: x.isoformat(), from_none], self.due_date)
        result["landAssessedCents"] = from_union([from_int, from_none], self.land_assessed_cents)
        result["lineItems"] = from_union([lambda x: from_list(lambda x: to_class(LineItem, x), x), from_none], self.line_items)
        result["miscAssessedCents"] = from_union([from_int, from_none], self.misc_assessed_cents)
        result["payments"] = from_union([lambda x: from_list(lambda x: to_class(Payment, x), x), from_none], self.payments)
        result["totalAssessedCents"] = from_union([from_int, from_none], self.total_assessed_cents)
        return result


@dataclass
class TaxPropInfo:
    assessment_date: Optional[datetime] = None
    building_appraised_cents: Optional[int] = None
    land_appraised_cents: Optional[int] = None
    legal_description: Optional[str] = None
    misc_appraised_cents: Optional[int] = None
    neighborhood: Optional[str] = None
    owner_address: Optional[str] = None
    owner_name: Optional[str] = None
    property_class: Optional[str] = None
    situs_address: Optional[str] = None
    tax_district: Optional[str] = None
    total_appraised_cents: Optional[int] = None
    zoning: Optional[str] = None

    @staticmethod
    def from_dict(obj: Any) -> 'TaxPropInfo':
        assert isinstance(obj, dict)
        assessment_date = from_union([(lambda x: x), from_none], obj.get("assessmentDate"))
        building_appraised_cents = from_union([from_int, from_none], obj.get("buildingAppraisedCents"))
        land_appraised_cents = from_union([from_int, from_none], obj.get("landAppraisedCents"))
        legal_description = from_union([from_str, from_none], obj.get("legalDescription"))
        misc_appraised_cents = from_union([from_int, from_none], obj.get("miscAppraisedCents"))
        neighborhood = from_union([from_str, from_none], obj.get("neighborhood"))
        owner_address = from_union([from_str, from_none], obj.get("ownerAddress"))
        owner_name = from_union([from_str, from_none], obj.get("ownerName"))
        property_class = from_union([from_str, from_none], obj.get("propertyClass"))
        situs_address = from_union([from_str, from_none], obj.get("situsAddress"))
        tax_district = from_union([from_str, from_none], obj.get("taxDistrict"))
        total_appraised_cents = from_union([from_int, from_none], obj.get("totalAppraisedCents"))
        zoning = from_union([from_str, from_none], obj.get("zoning"))
        return TaxPropInfo(assessment_date, building_appraised_cents, land_appraised_cents, legal_description, misc_appraised_cents, neighborhood, owner_address, owner_name, property_class, situs_address, tax_district, total_appraised_cents, zoning)

    def to_dict(self) -> dict:
        result: dict = {}
        result["assessmentDate"] = from_union([lambda x: x.isoformat(), from_none], self.assessment_date)
        result["buildingAppraisedCents"] = from_union([from_int, from_none], self.building_appraised_cents)
        result["landAppraisedCents"] = from_union([from_int, from_none], self.land_appraised_cents)
        result["legalDescription"] = from_union([from_str, from_none], self.legal_description)
        result["miscAppraisedCents"] = from_union([from_int, from_none], self.misc_appraised_cents)
        result["neighborhood"] = from_union([from_str, from_none], self.neighborhood)
        result["ownerAddress"] = from_union([from_str, from_none], self.owner_address)
        result["ownerName"] = from_union([from_str, from_none], self.owner_name)
        result["propertyClass"] = from_union([from_str, from_none], self.property_class)
        result["situsAddress"] = from_union([from_str, from_none], self.situs_address)
        result["taxDistrict"] = from_union([from_str, from_none], self.tax_district)
        result["totalAppraisedCents"] = from_union([from_int, from_none], self.total_appraised_cents)
        result["zoning"] = from_union([from_str, from_none], self.zoning)
        return result


@dataclass
class Property:
    """A set of one or more parcels that constitute a single logic piece of real estate"""
    id: ObjectId
    """A placeholder where errors concerning the object can go"""
    error: Optional[str] = None
    """The id of the user that created this object"""
    created_by: Optional[ObjectId] = None
    """The date the object was first created"""
    created_date: Optional[datetime] = None
    """The id of the user that last modified this object"""
    last_modified_by: Optional[ObjectId] = None
    """The date of the last update to the object"""
    modified_date: Optional[datetime] = None
    acreage: Optional[float] = None
    """WKT of the boundary of the property"""
    boundary: Optional[str] = None
    city: Optional[str] = None
    contact_ids: Optional[List[ObjectId]] = None
    county: Optional[str] = None
    description: Optional[str] = None
    desired_rent_cents: Optional[int] = None
    desired_sales_price_dollars: Optional[int] = None
    """If set to true, the GIS parcel information for this property should be refreshed"""
    gis_refresh_requested: Optional[bool] = None
    insurance_policy_ids: Optional[List[ObjectId]] = None
    lease_ids: Optional[List[ObjectId]] = None
    media_ids: Optional[List[ObjectId]] = None
    name: Optional[str] = None
    note_ids: Optional[List[ObjectId]] = None
    owners: Optional[List[Owner]] = None
    pin_numbers: Optional[List[str]] = None
    prop_type: Optional[PropType] = None
    state: Optional[str] = None
    tags: Optional[List[str]] = None
    tax_bills: Optional[Dict[str, Dict[str, TaxBill]]] = None
    tax_prop_info: Optional[Dict[str, TaxPropInfo]] = None
    tax_refresh_requested: Optional[bool] = None

    @staticmethod
    def from_dict(obj: Any) -> 'Property':
        assert isinstance(obj, dict)
        id = (lambda x: x)(obj.get("_id"))
        error = from_union([from_str, from_none], obj.get("_error"))
        created_by = from_union([(lambda x: x), from_none], obj.get("createdBy"))
        created_date = from_union([(lambda x: x), from_none], obj.get("createdDate"))
        last_modified_by = from_union([(lambda x: x), from_none], obj.get("lastModifiedBy"))
        modified_date = from_union([(lambda x: x), from_none], obj.get("modifiedDate"))
        acreage = from_union([from_float, from_none], obj.get("acreage"))
        boundary = from_union([from_str, from_none], obj.get("boundary"))
        city = from_union([from_str, from_none], obj.get("city"))
        contact_ids = from_union([lambda x: from_list((lambda x: x), x), from_none], obj.get("contactIds"))
        county = from_union([from_str, from_none], obj.get("county"))
        description = from_union([from_str, from_none], obj.get("description"))
        desired_rent_cents = from_union([from_int, from_none], obj.get("desiredRentCents"))
        desired_sales_price_dollars = from_union([from_int, from_none], obj.get("desiredSalesPriceDollars"))
        gis_refresh_requested = from_union([from_bool, from_none], obj.get("gisRefreshRequested"))
        insurance_policy_ids = from_union([lambda x: from_list((lambda x: x), x), from_none], obj.get("insurancePolicyIds"))
        lease_ids = from_union([lambda x: from_list((lambda x: x), x), from_none], obj.get("leaseIds"))
        media_ids = from_union([lambda x: from_list((lambda x: x), x), from_none], obj.get("mediaIds"))
        name = from_union([from_str, from_none], obj.get("name"))
        note_ids = from_union([lambda x: from_list((lambda x: x), x), from_none], obj.get("noteIds"))
        owners = from_union([lambda x: from_list(Owner.from_dict, x), from_none], obj.get("owners"))
        pin_numbers = from_union([lambda x: from_list(from_str, x), from_none], obj.get("pinNumbers"))
        prop_type = from_union([PropType, from_none], obj.get("propType"))
        state = from_union([from_str, from_none], obj.get("state"))
        tags = from_union([lambda x: from_list(from_str, x), from_none], obj.get("tags"))
        tax_bills = from_union([lambda x: from_dict(lambda x: from_dict(TaxBill.from_dict, x), x), from_none], obj.get("taxBills"))
        tax_prop_info = from_union([lambda x: from_dict(TaxPropInfo.from_dict, x), from_none], obj.get("taxPropInfo"))
        tax_refresh_requested = from_union([from_bool, from_none], obj.get("taxRefreshRequested"))
        return Property(id, error, created_by, created_date, last_modified_by, modified_date, acreage, boundary, city, contact_ids, county, description, desired_rent_cents, desired_sales_price_dollars, gis_refresh_requested, insurance_policy_ids, lease_ids, media_ids, name, note_ids, owners, pin_numbers, prop_type, state, tags, tax_bills, tax_prop_info, tax_refresh_requested)

    def to_dict(self) -> dict:
        result: dict = {}
        result["_id"] = to_class(ObjectId, self.id)
        result["_error"] = from_union([from_str, from_none], self.error)
        result["createdBy"] = from_union([lambda x: to_class(ObjectId, x), from_none], self.created_by)
        result["createdDate"] = from_union([lambda x: x.isoformat(), from_none], self.created_date)
        result["lastModifiedBy"] = from_union([lambda x: to_class(ObjectId, x), from_none], self.last_modified_by)
        result["modifiedDate"] = from_union([lambda x: x.isoformat(), from_none], self.modified_date)
        result["acreage"] = from_union([to_float, from_none], self.acreage)
        result["boundary"] = from_union([from_str, from_none], self.boundary)
        result["city"] = from_union([from_str, from_none], self.city)
        result["contactIds"] = from_union([lambda x: from_list(lambda x: to_class(ObjectId, x), x), from_none], self.contact_ids)
        result["county"] = from_union([from_str, from_none], self.county)
        result["description"] = from_union([from_str, from_none], self.description)
        result["desiredRentCents"] = from_union([from_int, from_none], self.desired_rent_cents)
        result["desiredSalesPriceDollars"] = from_union([from_int, from_none], self.desired_sales_price_dollars)
        result["gisRefreshRequested"] = from_union([from_bool, from_none], self.gis_refresh_requested)
        result["insurancePolicyIds"] = from_union([lambda x: from_list(lambda x: to_class(ObjectId, x), x), from_none], self.insurance_policy_ids)
        result["leaseIds"] = from_union([lambda x: from_list(lambda x: to_class(ObjectId, x), x), from_none], self.lease_ids)
        result["mediaIds"] = from_union([lambda x: from_list(lambda x: to_class(ObjectId, x), x), from_none], self.media_ids)
        result["name"] = from_union([from_str, from_none], self.name)
        result["noteIds"] = from_union([lambda x: from_list(lambda x: to_class(ObjectId, x), x), from_none], self.note_ids)
        result["owners"] = from_union([lambda x: from_list(lambda x: to_class(Owner, x), x), from_none], self.owners)
        result["pinNumbers"] = from_union([lambda x: from_list(from_str, x), from_none], self.pin_numbers)
        result["propType"] = from_union([lambda x: to_enum(PropType, x), from_none], self.prop_type)
        result["state"] = from_union([from_str, from_none], self.state)
        result["tags"] = from_union([lambda x: from_list(from_str, x), from_none], self.tags)
        result["taxBills"] = from_union([lambda x: from_dict(lambda x: from_dict(lambda x: to_class(TaxBill, x), x), x), from_none], self.tax_bills)
        result["taxPropInfo"] = from_union([lambda x: from_dict(lambda x: to_class(TaxPropInfo, x), x), from_none], self.tax_prop_info)
        result["taxRefreshRequested"] = from_union([from_bool, from_none], self.tax_refresh_requested)
        return result


@dataclass
class User:
    """A user in the system"""
    id: ObjectId
    disabled: bool
    username: str
    """A placeholder where errors concerning the object can go"""
    error: Optional[str] = None
    """The id of the user that created this object"""
    created_by: Optional[ObjectId] = None
    """The date the object was first created"""
    created_date: Optional[datetime] = None
    """The id of the user that last modified this object"""
    last_modified_by: Optional[ObjectId] = None
    """The date of the last update to the object"""
    modified_date: Optional[datetime] = None
    email: Optional[str] = None
    first_name: Optional[str] = None
    last_name: Optional[str] = None
    password_hashed: Optional[str] = None
    session_ids: Optional[List[str]] = None

    @staticmethod
    def from_dict(obj: Any) -> 'User':
        assert isinstance(obj, dict)
        id = (lambda x: x)(obj.get("_id"))
        disabled = from_bool(obj.get("disabled"))
        username = from_str(obj.get("username"))
        error = from_union([from_str, from_none], obj.get("_error"))
        created_by = from_union([(lambda x: x), from_none], obj.get("createdBy"))
        created_date = from_union([(lambda x: x), from_none], obj.get("createdDate"))
        last_modified_by = from_union([(lambda x: x), from_none], obj.get("lastModifiedBy"))
        modified_date = from_union([(lambda x: x), from_none], obj.get("modifiedDate"))
        email = from_union([from_str, from_none], obj.get("email"))
        first_name = from_union([from_str, from_none], obj.get("firstName"))
        last_name = from_union([from_str, from_none], obj.get("lastName"))
        password_hashed = from_union([from_str, from_none], obj.get("passwordHashed"))
        session_ids = from_union([lambda x: from_list(from_str, x), from_none], obj.get("sessionIds"))
        return User(id, disabled, username, error, created_by, created_date, last_modified_by, modified_date, email, first_name, last_name, password_hashed, session_ids)

    def to_dict(self) -> dict:
        result: dict = {}
        result["_id"] = to_class(ObjectId, self.id)
        result["disabled"] = from_bool(self.disabled)
        result["username"] = from_str(self.username)
        result["_error"] = from_union([from_str, from_none], self.error)
        result["createdBy"] = from_union([lambda x: to_class(ObjectId, x), from_none], self.created_by)
        result["createdDate"] = from_union([lambda x: x.isoformat(), from_none], self.created_date)
        result["lastModifiedBy"] = from_union([lambda x: to_class(ObjectId, x), from_none], self.last_modified_by)
        result["modifiedDate"] = from_union([lambda x: x.isoformat(), from_none], self.modified_date)
        result["email"] = from_union([from_str, from_none], self.email)
        result["firstName"] = from_union([from_str, from_none], self.first_name)
        result["lastName"] = from_union([from_str, from_none], self.last_name)
        result["passwordHashed"] = from_union([from_str, from_none], self.password_hashed)
        result["sessionIds"] = from_union([lambda x: from_list(from_str, x), from_none], self.session_ids)
        return result


def collection_name_from_dict(s: Any) -> CollectionName:
    return CollectionName(s)


def collection_name_to_dict(x: CollectionName) -> Any:
    return to_enum(CollectionName, x)


def common_from_dict(s: Any) -> Any:
    return s


def common_to_dict(x: Any) -> Any:
    return x


def insurance_policy_from_dict(s: Any) -> InsurancePolicy:
    return InsurancePolicy.from_dict(s)


def insurance_policy_to_dict(x: InsurancePolicy) -> Any:
    return to_class(InsurancePolicy, x)


def lease_from_dict(s: Any) -> Lease:
    return Lease.from_dict(s)


def lease_to_dict(x: Lease) -> Any:
    return to_class(Lease, x)


def media_from_dict(s: Any) -> Media:
    return Media.from_dict(s)


def media_to_dict(x: Media) -> Any:
    return to_class(Media, x)


def mongo_doc_from_dict(s: Any) -> MongoDoc:
    return MongoDoc.from_dict(s)


def mongo_doc_to_dict(x: MongoDoc) -> Any:
    return to_class(MongoDoc, x)


def note_from_dict(s: Any) -> Note:
    return Note.from_dict(s)


def note_to_dict(x: Note) -> Any:
    return to_class(Note, x)


def parcel_info_from_dict(s: Any) -> ParcelInfo:
    return ParcelInfo.from_dict(s)


def parcel_info_to_dict(x: ParcelInfo) -> Any:
    return to_class(ParcelInfo, x)


def party_from_dict(s: Any) -> Party:
    return Party.from_dict(s)


def party_to_dict(x: Party) -> Any:
    return to_class(Party, x)


def property_from_dict(s: Any) -> Property:
    return Property.from_dict(s)


def property_to_dict(x: Property) -> Any:
    return to_class(Property, x)


def user_from_dict(s: Any) -> User:
    return User.from_dict(s)


def user_to_dict(x: User) -> Any:
    return to_class(User, x)
